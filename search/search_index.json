{
    "docs": [
        {
            "location": "/", 
            "text": "Tusk\n\n\n\n\n\n\n\n\n\n\n\n\nTusk is a yaml-based task runner. By creating a \ntusk.yml\n in the root of a\nrepository, Tusk becomes a custom command line tool with minimal configuration.\n\n\nDetails on the usage and configuration options can be found in the \nproject\ndocumentation\n.\n\n\nFeatures\n\n\n\n\nCustomizable\n: Specify your own tasks and options with support for command-line\n  flags, environment variables, conditional logic, and more.\n\n\nExplorable\n: With help documentation generated dynamically and support for Bash\n  and Zsh tab completion available, all the help you need to get started in a\n  project is available straight from the command line.\n\n\nAccessible\n: Built for usability with a simple YAML configuration, familiar\n  syntax for passing options, Bash-like variable interpolation, and a colorful\n  terminal output.\n\n\nZero Dependencies\n: All you need is a single binary file to get started on\n  Linux, macOS, or Windows.\n\n\n\n\nGetting Started\n\n\nInstallation\n\n\nThe latest version can be installed from the \nreleases page\n.\n\n\nOn macOS, installation is also available through \nhomebrew\n:\n\n\nbrew install rliebz/tusk/tusk\n\n\n\n\nUsage\n\n\nCreate a \ntusk.yml\n file in the root of a project repository:\n\n\ntasks:\n  greet:\n    usage: Say hello to someone\n    options:\n      name:\n        usage: A person to say \nHello\n to\n        default: World\n    run: echo \nHello, ${name}!\n\n\n\n\nAs long as there is a \ntusk.yml\n file in the working or any parent directory,\ntasks can be run:\n\n\n$ tusk greet --name friend\nRunning: echo \nHello, friend!\n\nHello, friend!\n\n\n\n\nHelp messages are dynamically generated based on the YAML configuration:\n\n\n$ tusk --help\ntusk - the modern task runner\n\nUsage:\n   tusk [global options] \ntask\n [task options]\n\nTasks:\n   greet  Say hello to someone\n\nGlobal Options:\n   -f, --file \nfile\n  Set file to use as the config file\n   -h, --help         Show help and exit\n   ...\n\n\n\n\nIndividual tasks have help messages as well:\n\n\n$ tusk greet --help\ntusk greet - Say hello to someone\n\nUsage:\n   tusk greet [options]\n\nOptions:\n   --name value  A person to say \nHello\n to\n\n\n\n\nAdditional information on the configuration spec can be found in the \nproject\ndocumentation\n.\n\n\nFor more detailed examples, check out the project's own \ntusk.yml\n\nfile.\n\n\nContributing\n\n\nSet-up instructions for a development environment and contribution guidelines\ncan be found in \nCONTRIBUTING.md\n.", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#tusk", 
            "text": "Tusk is a yaml-based task runner. By creating a  tusk.yml  in the root of a\nrepository, Tusk becomes a custom command line tool with minimal configuration.  Details on the usage and configuration options can be found in the  project\ndocumentation .", 
            "title": "Tusk"
        }, 
        {
            "location": "/#features", 
            "text": "Customizable : Specify your own tasks and options with support for command-line\n  flags, environment variables, conditional logic, and more.  Explorable : With help documentation generated dynamically and support for Bash\n  and Zsh tab completion available, all the help you need to get started in a\n  project is available straight from the command line.  Accessible : Built for usability with a simple YAML configuration, familiar\n  syntax for passing options, Bash-like variable interpolation, and a colorful\n  terminal output.  Zero Dependencies : All you need is a single binary file to get started on\n  Linux, macOS, or Windows.", 
            "title": "Features"
        }, 
        {
            "location": "/#getting-started", 
            "text": "", 
            "title": "Getting Started"
        }, 
        {
            "location": "/#installation", 
            "text": "The latest version can be installed from the  releases page .  On macOS, installation is also available through  homebrew :  brew install rliebz/tusk/tusk", 
            "title": "Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "Create a  tusk.yml  file in the root of a project repository:  tasks:\n  greet:\n    usage: Say hello to someone\n    options:\n      name:\n        usage: A person to say  Hello  to\n        default: World\n    run: echo  Hello, ${name}!  As long as there is a  tusk.yml  file in the working or any parent directory,\ntasks can be run:  $ tusk greet --name friend\nRunning: echo  Hello, friend! \nHello, friend!  Help messages are dynamically generated based on the YAML configuration:  $ tusk --help\ntusk - the modern task runner\n\nUsage:\n   tusk [global options]  task  [task options]\n\nTasks:\n   greet  Say hello to someone\n\nGlobal Options:\n   -f, --file  file   Set file to use as the config file\n   -h, --help         Show help and exit\n   ...  Individual tasks have help messages as well:  $ tusk greet --help\ntusk greet - Say hello to someone\n\nUsage:\n   tusk greet [options]\n\nOptions:\n   --name value  A person to say  Hello  to  Additional information on the configuration spec can be found in the  project\ndocumentation .  For more detailed examples, check out the project's own  tusk.yml \nfile.", 
            "title": "Usage"
        }, 
        {
            "location": "/#contributing", 
            "text": "Set-up instructions for a development environment and contribution guidelines\ncan be found in  CONTRIBUTING.md .", 
            "title": "Contributing"
        }, 
        {
            "location": "/spec/", 
            "text": "The Spec\n\n\nTasks\n\n\nThe core of every \ntusk.yml\n file is a list of tasks. Tasks are declared at the\ntop level of the \ntusk.yml\n file and include a list of tasks.\n\n\nFor the following tasks:\n\n\ntasks:\n  hello:\n    run: echo \nHello, world!\n\n  goodbye:\n    run: echo \nGoodbye, world!\n\n\n\n\nThe commands can be run with no additional configuration:\n\n\n$ tusk hello\nRunning: echo \nHello, world!\n\nHello, world!\n\n\n\n\nTasks can be documented with a one-line \nusage\n string and a slightly longer\n\ndescription\n. This information will be displayed in help messages:\n\n\ntasks:\n  hello:\n    usage: Say hello to the world\n    description: |\n      This command will echo \nHello, world!\n to the user. There's no\n      surprises here.\n    run: echo \nHello, world!\n\n  goodbye:\n    run: echo \nGoodbye, world!\n\n\n\n\nRun\n\n\nThe behavior of a task is defined in its \nrun\n clause. A \nrun\n clause can be\nused for commands, sub-tasks, or setting environment variables. Although each\n\nrun\n item can only perform one of these actions, they can be run in succession\nto handle complex scenarios.\n\n\nCommand\n\n\nIn its simplest form, \nrun\n can be given a string or list of strings to be\nexecuted serially as shell commands:\n\n\ntasks:\n  hello:\n    run: echo \nHello!\n\n\n\n\nThis is a shorthand syntax for the following:\n\n\ntasks:\n  hello:\n    run:\n      - command: echo \nHello!\n\n\n\n\nIf any of the run commands execute with a non-zero exit code, Tusk will\nimmediately exit with the same exit code without executing any other commands.\n\n\nFor executing shell commands, the interpreter used will be the value of the\n\nSHELL\n environment variable. If no environment variable is set, the default is\n\nsh\n.\n\n\nSet Environment\n\n\nThe second type of action a \nrun\n clause can perform is setting or unsetting\nenvironment variables. To do so, simply define a map of environment variable\nnames to their desired values:\n\n\ntasks:\n  hello:\n    options:\n      proxy-url:\n        default: http://proxy.example.com\n    run:\n      - set-environment:\n          http_proxy: ${proxy-url}\n          https_proxy: ${proxy-url}\n          no_proxy: ~\n      - command: curl http://example.com\n\n\n\n\nPassing \n~\n or \nnull\n to an environment variable will explicitly unset it, while\npassing an empty string will set it to an empty string.\n\n\nSub-Tasks\n\n\nRun can also execute previously-defined tasks:\n\n\ntasks:\n  one:\n    run: echo \nInside one\n\n  two:\n    run:\n      - task: one\n      - command: echo \nInside two\n\n\n\n\nFor any arg or option that a sub-task defines, the parent task can pass a\nvalue, which is treated the same way as passing by command-line would be. Args\nare passed in as a list, while options are a map from flag name to value.\n\n\nTo pass values, use the long definition of a sub-task:\n\n\ntasks:\n  greet:\n    args:\n      name:\n        usage: The person to greet\n    options:\n      greeting:\n        default: Hello\n    run: echo \n${greeting}, ${person}!\n\n  greet-myself:\n    run:\n      task:\n        name: greet\n        args:\n          - me\n        options:\n          greeting: Howdy\n\n\n\n\nIn cases where a sub-task may not be useful on its own, define it as private to\nprevent it from being invoked directly from the command-line. For example:\n\n\ntasks:\n  configure-environment:\n    private: true\n    run:\n      set-environment: {APP_ENV: dev}\n  serve:\n    run:\n      - task: configure-environment\n      - command: python main.py\n\n\n\n\nWhen\n\n\nFor conditional execution, \nwhen\n clauses are available.\n\n\nrun:\n  when:\n    os: linux\n  command: echo \nThis is a linux machine\n\n\n\n\nIn a \nrun\n clause, any item with a true \nwhen\n clause will execute. There are\nfive different checks supported:\n\n\n\n\ncommand\n (string): Execute if the command runs with an exit code of \n0\n.\n\n\nexists\n (string): Execute if the file exists.\n\n\nos\n (list): Execute if the operating system matches any one from the list.\n\n\nenvironment\n (map[string -\n string]): Execute if the environment variable\n  matches the value it maps to. To check if a variable is not set, the value\n  should be \n~\n or \nnull\n.\n\n\nequal\n (map[string -\n string]): Execute if the given option equals the value\n  it maps to.\n\n\nnot-equal\n (map[string -\n string]): Execute if the given option does not\n  equal the value it maps to.\n\n\n\n\nThe \nwhen\n clause supports any number of different checks as a list, where each\ncheck must pass individually for the clause to evaluate to true. Here is a more\ncomplicated example of how \nwhen\n can be used:\n\n\ntasks:\n  echo:\n    options:\n      cat:\n        usage: Cat a file\n    run:\n      - when:\n          os:\n            - linux\n            - darwin\n        command: echo \nThis is a unix machine\n\n      - when:\n          - exists: my_file.txt\n          - equal: {cat: true}\n          - command: command -v cat\n        command: cat my_file.txt\n\n\n\n\nArgs\n\n\nTasks may have args that are passed directly as inputs. Any arg that is defined\nis required for the task to execute.\n\n\ntasks:\n  greet:\n    args:\n      name:\n        usage: The person to greet\n    run: echo \nHello, ${name}!\n\n\n\n\nThe task can be invoked as such:\n\n\n$ tusk greet friend\nHello, friend!\n\n\n\n\nArg Values\n\n\nArgs can specify which values are considered valid:\n\n\ntasks:\n  greet:\n    args:\n      name:\n        values:\n          - Abby\n          - Bobby\n          - Carl\n\n\n\n\nAny value passed by command-line must be one of the listed values, or the\ncommand will fail to execute.\n\n\nOptions\n\n\nTasks may have options that are passed as GNU-style flags. The following\nconfiguration will provide \n-n, --name\n flags to the CLI and help documentation,\nwhich will then be interpolated:\n\n\ntasks:\n  greet:\n    options:\n      name:\n        usage: The person to greet\n        short: n\n        environment: GREET_NAME\n        default: World\n    run: echo \nHello, ${name}!\n\n\n\n\nThe above configuration will evaluate the value of \nname\n in order of highest\npriority:\n\n\n\n\nThe value passed by command line flags (\n-n\n or \n--name\n)\n\n\nThe value of the environment variable (\nGREET_NAME\n), if set\n\n\nThe value set in default\n\n\n\n\nOption Types\n\n\nOptions can be of the types \nstring\n, \ninteger\n, \nfloat\n, or \nboolean\n, using\nthe zero-value of that type as the default if not set. Options without types\nspecified are considered strings.\n\n\nFor boolean values, the flag should be passed by command line without any\narugments. In the following example:\n\n\ntasks:\n  greet:\n    options:\n      loud:\n        type: bool\n    run:\n      - when:\n          equal: {loud: true}\n        command: echo \nHELLO!\n\n      - when:\n          equal: {loud: false}\n        command: echo \nHello.\n\n\n\n\nThe flag should be passed as such:\n\n\ntusk greet --loud\n\n\n\n\nThis means that for an option that is true by default, the only way to disable\nit is with the following syntax:\n\n\ntusk greet --loud=false\n\n\n\n\nOf course, options can always be defined in the reverse manner to avoid this\nissue:\n\n\noptions:\n  no-loud:\n    type: bool\n\n\n\n\nOption Defaults\n\n\nMuch like \nrun\n clauses accept a shorthand form, passing a string to \ndefault\n\nis shorthand. The following options are exactly equivalent:\n\n\noptions:\n  short:\n    default: foo\n  long:\n    default:\n      - value: foo\n\n\n\n\nA \ndefault\n clause can also register the \nstdout\n of a command as its value:\n\n\noptions:\n  os:\n    default:\n      command: uname -s\n\n\n\n\nA \ndefault\n clause also accepts a list of possible values with a corresponding\n\nwhen\n clause. The first \nwhen\n that evaluates to true will be used as the\ndefault value, with an omitted \nwhen\n always considered true.\n\n\nIn this example, linux users will have the name \nLinux User\n, while the default\nfor all other OSes is \nUser\n:\n\n\noptions:\n  name:\n    default:\n      - when:\n          os: linux\n        value: Linux User\n      - value: User\n\n\n\n\nOption Values\n\n\nLike args, an option can specify which values are considered valid:\n\n\noptions:\n  number:\n    default: zero\n    values:\n      - one\n      - two\n      - three\n\n\n\n\nAny value passed by command-line flags or environment variables must be one of\nthe listed values. Default values, including commands, are excluded from this\nrequirement.\n\n\nRequired Options\n\n\nOptions may be required if there is no sane default value. For a required flag,\nthe task will not execute unless the flag is passed:\n\n\noptions:\n  file:\n    required: true\n\n\n\n\nA required option cannot be private or have any default values.\n\n\nPrivate Options\n\n\nSometimes it may be desirable to have a variable that cannot be directly\nmodified through command-line flags. In this case, use the \nprivate\n option:\n\n\noptions:\n  user:\n    private: true\n    default:\n      command: whoami\n\n\n\n\nA private option will not accept environment variables or command line flags,\nand it will not appear in the help documentation.\n\n\nShared Options\n\n\nOptions may also be defined at the root of the config file to be shared between\ntasks:\n\n\noptions:\n  name:\n    usage: The person to greet\n    default: World\n\ntasks:\n  hello:\n    run: echo \nHello, ${name}!\n\n  goodbye:\n    run: echo \nGoodbye, ${name}!\n\n\n\n\nAny shared variables referenced by a task will be exposed by command-line when\ninvoking that task. Shared variables referenced by a sub-task will be evaluated\nas needed, but not exposed by command-line.\n\n\nTasks that define an argument or option with the same name as a shared task will\noverwrite the value of the shared option for the length of that task, not\nincluding sub-tasks.\n\n\nCLI Metadata\n\n\nIt is also possible to create a custom CLI tool for use outside of a project's\ndirectory by using shell aliases:\n\n\nalias mycli=\ntusk -f /path/to/tusk.yml\n\n\n\n\nIn that case, it may be useful to override the tool name and usage text that\nare provided as part of the help documentation:\n\n\nname: mycli\nusage: A custom aliased command-line application\n\ntasks:\n  ...\n\n\n\n\nThe example above will produce the following help documentation:\n\n\nmycli - A custom aliased command-line application\n\nUsage:\n  mycli [global options] \ntask\n [task options]\n\nTasks:\n  ...\n\n\n\n\nInterpolation\n\n\nThe interpolation syntax for a variable \nfoo\n is \n${foo}\n, meaning any instances\nof \n${foo}\n in the configuration file will be replaced with the value of \nfoo\n\nduring execution.\n\n\nInterpolation is done on a task-by-task basis, meaning args and options defined\nin one task will not interpolate to any other tasks. Shared options, on the\nother hand, will only be evaluated once per execution.\n\n\nThe execution order is as followed:\n\n\n\n\nShared options are interpolated first, in the order defined by the config\n   file. The results of global interpolation are cached and not re-run.\n\n\nThe args for the current task being run are interpolated, in order.\n\n\nThe options for the current task being run are interpolated, in order.\n\n\nFor each call to a sub-task, the process is repeated, ignoring the task-\n   specific interpolations for parent tasks, using the cached shared options.\n\n\n\n\nThis means that options can reference other options or args:\n\n\noptions:\n  name:\n    default: World\n  greeting:\n    default: Hello, ${name}\n\ntasks:\n  greet:\n    run: echo \n${greeting}\n\n\n\n\nBecause interpolation is not always desirable, as in the case of environment\nvariables, \n$$\n will escape to \n$\n and ignore interpolation. It is also\npossible to use alternative syntax such as \n$foo\n to avoid interpolation as\nwell. The following two tasks will both use environment variables and not\nattempt interpolation:\n\n\ntasks:\n  one:\n    run: Hello, $${USER}\n  two:\n    run: Hello, $USER\n\n\n\n\nInterpolation works by substituting the value in the \nyaml\n config file, then\nparsing the file after interpolation. This means that variable values with\nnewlines or other characters that are relevant to the \nyaml\n spec or the \nsh\n\ninterpreter will need to be considered by the user. This can be as simple as\nusing quotes when appropriate.", 
            "title": "The Spec"
        }, 
        {
            "location": "/spec/#the-spec", 
            "text": "", 
            "title": "The Spec"
        }, 
        {
            "location": "/spec/#tasks", 
            "text": "The core of every  tusk.yml  file is a list of tasks. Tasks are declared at the\ntop level of the  tusk.yml  file and include a list of tasks.  For the following tasks:  tasks:\n  hello:\n    run: echo  Hello, world! \n  goodbye:\n    run: echo  Goodbye, world!  The commands can be run with no additional configuration:  $ tusk hello\nRunning: echo  Hello, world! \nHello, world!  Tasks can be documented with a one-line  usage  string and a slightly longer description . This information will be displayed in help messages:  tasks:\n  hello:\n    usage: Say hello to the world\n    description: |\n      This command will echo  Hello, world!  to the user. There's no\n      surprises here.\n    run: echo  Hello, world! \n  goodbye:\n    run: echo  Goodbye, world!", 
            "title": "Tasks"
        }, 
        {
            "location": "/spec/#run", 
            "text": "The behavior of a task is defined in its  run  clause. A  run  clause can be\nused for commands, sub-tasks, or setting environment variables. Although each run  item can only perform one of these actions, they can be run in succession\nto handle complex scenarios.", 
            "title": "Run"
        }, 
        {
            "location": "/spec/#command", 
            "text": "In its simplest form,  run  can be given a string or list of strings to be\nexecuted serially as shell commands:  tasks:\n  hello:\n    run: echo  Hello!  This is a shorthand syntax for the following:  tasks:\n  hello:\n    run:\n      - command: echo  Hello!  If any of the run commands execute with a non-zero exit code, Tusk will\nimmediately exit with the same exit code without executing any other commands.  For executing shell commands, the interpreter used will be the value of the SHELL  environment variable. If no environment variable is set, the default is sh .", 
            "title": "Command"
        }, 
        {
            "location": "/spec/#set-environment", 
            "text": "The second type of action a  run  clause can perform is setting or unsetting\nenvironment variables. To do so, simply define a map of environment variable\nnames to their desired values:  tasks:\n  hello:\n    options:\n      proxy-url:\n        default: http://proxy.example.com\n    run:\n      - set-environment:\n          http_proxy: ${proxy-url}\n          https_proxy: ${proxy-url}\n          no_proxy: ~\n      - command: curl http://example.com  Passing  ~  or  null  to an environment variable will explicitly unset it, while\npassing an empty string will set it to an empty string.", 
            "title": "Set Environment"
        }, 
        {
            "location": "/spec/#sub-tasks", 
            "text": "Run can also execute previously-defined tasks:  tasks:\n  one:\n    run: echo  Inside one \n  two:\n    run:\n      - task: one\n      - command: echo  Inside two  For any arg or option that a sub-task defines, the parent task can pass a\nvalue, which is treated the same way as passing by command-line would be. Args\nare passed in as a list, while options are a map from flag name to value.  To pass values, use the long definition of a sub-task:  tasks:\n  greet:\n    args:\n      name:\n        usage: The person to greet\n    options:\n      greeting:\n        default: Hello\n    run: echo  ${greeting}, ${person}! \n  greet-myself:\n    run:\n      task:\n        name: greet\n        args:\n          - me\n        options:\n          greeting: Howdy  In cases where a sub-task may not be useful on its own, define it as private to\nprevent it from being invoked directly from the command-line. For example:  tasks:\n  configure-environment:\n    private: true\n    run:\n      set-environment: {APP_ENV: dev}\n  serve:\n    run:\n      - task: configure-environment\n      - command: python main.py", 
            "title": "Sub-Tasks"
        }, 
        {
            "location": "/spec/#when", 
            "text": "For conditional execution,  when  clauses are available.  run:\n  when:\n    os: linux\n  command: echo  This is a linux machine  In a  run  clause, any item with a true  when  clause will execute. There are\nfive different checks supported:   command  (string): Execute if the command runs with an exit code of  0 .  exists  (string): Execute if the file exists.  os  (list): Execute if the operating system matches any one from the list.  environment  (map[string -  string]): Execute if the environment variable\n  matches the value it maps to. To check if a variable is not set, the value\n  should be  ~  or  null .  equal  (map[string -  string]): Execute if the given option equals the value\n  it maps to.  not-equal  (map[string -  string]): Execute if the given option does not\n  equal the value it maps to.   The  when  clause supports any number of different checks as a list, where each\ncheck must pass individually for the clause to evaluate to true. Here is a more\ncomplicated example of how  when  can be used:  tasks:\n  echo:\n    options:\n      cat:\n        usage: Cat a file\n    run:\n      - when:\n          os:\n            - linux\n            - darwin\n        command: echo  This is a unix machine \n      - when:\n          - exists: my_file.txt\n          - equal: {cat: true}\n          - command: command -v cat\n        command: cat my_file.txt", 
            "title": "When"
        }, 
        {
            "location": "/spec/#args", 
            "text": "Tasks may have args that are passed directly as inputs. Any arg that is defined\nis required for the task to execute.  tasks:\n  greet:\n    args:\n      name:\n        usage: The person to greet\n    run: echo  Hello, ${name}!  The task can be invoked as such:  $ tusk greet friend\nHello, friend!", 
            "title": "Args"
        }, 
        {
            "location": "/spec/#arg-values", 
            "text": "Args can specify which values are considered valid:  tasks:\n  greet:\n    args:\n      name:\n        values:\n          - Abby\n          - Bobby\n          - Carl  Any value passed by command-line must be one of the listed values, or the\ncommand will fail to execute.", 
            "title": "Arg Values"
        }, 
        {
            "location": "/spec/#options", 
            "text": "Tasks may have options that are passed as GNU-style flags. The following\nconfiguration will provide  -n, --name  flags to the CLI and help documentation,\nwhich will then be interpolated:  tasks:\n  greet:\n    options:\n      name:\n        usage: The person to greet\n        short: n\n        environment: GREET_NAME\n        default: World\n    run: echo  Hello, ${name}!  The above configuration will evaluate the value of  name  in order of highest\npriority:   The value passed by command line flags ( -n  or  --name )  The value of the environment variable ( GREET_NAME ), if set  The value set in default", 
            "title": "Options"
        }, 
        {
            "location": "/spec/#option-types", 
            "text": "Options can be of the types  string ,  integer ,  float , or  boolean , using\nthe zero-value of that type as the default if not set. Options without types\nspecified are considered strings.  For boolean values, the flag should be passed by command line without any\narugments. In the following example:  tasks:\n  greet:\n    options:\n      loud:\n        type: bool\n    run:\n      - when:\n          equal: {loud: true}\n        command: echo  HELLO! \n      - when:\n          equal: {loud: false}\n        command: echo  Hello.  The flag should be passed as such:  tusk greet --loud  This means that for an option that is true by default, the only way to disable\nit is with the following syntax:  tusk greet --loud=false  Of course, options can always be defined in the reverse manner to avoid this\nissue:  options:\n  no-loud:\n    type: bool", 
            "title": "Option Types"
        }, 
        {
            "location": "/spec/#option-defaults", 
            "text": "Much like  run  clauses accept a shorthand form, passing a string to  default \nis shorthand. The following options are exactly equivalent:  options:\n  short:\n    default: foo\n  long:\n    default:\n      - value: foo  A  default  clause can also register the  stdout  of a command as its value:  options:\n  os:\n    default:\n      command: uname -s  A  default  clause also accepts a list of possible values with a corresponding when  clause. The first  when  that evaluates to true will be used as the\ndefault value, with an omitted  when  always considered true.  In this example, linux users will have the name  Linux User , while the default\nfor all other OSes is  User :  options:\n  name:\n    default:\n      - when:\n          os: linux\n        value: Linux User\n      - value: User", 
            "title": "Option Defaults"
        }, 
        {
            "location": "/spec/#option-values", 
            "text": "Like args, an option can specify which values are considered valid:  options:\n  number:\n    default: zero\n    values:\n      - one\n      - two\n      - three  Any value passed by command-line flags or environment variables must be one of\nthe listed values. Default values, including commands, are excluded from this\nrequirement.", 
            "title": "Option Values"
        }, 
        {
            "location": "/spec/#required-options", 
            "text": "Options may be required if there is no sane default value. For a required flag,\nthe task will not execute unless the flag is passed:  options:\n  file:\n    required: true  A required option cannot be private or have any default values.", 
            "title": "Required Options"
        }, 
        {
            "location": "/spec/#private-options", 
            "text": "Sometimes it may be desirable to have a variable that cannot be directly\nmodified through command-line flags. In this case, use the  private  option:  options:\n  user:\n    private: true\n    default:\n      command: whoami  A private option will not accept environment variables or command line flags,\nand it will not appear in the help documentation.", 
            "title": "Private Options"
        }, 
        {
            "location": "/spec/#shared-options", 
            "text": "Options may also be defined at the root of the config file to be shared between\ntasks:  options:\n  name:\n    usage: The person to greet\n    default: World\n\ntasks:\n  hello:\n    run: echo  Hello, ${name}! \n  goodbye:\n    run: echo  Goodbye, ${name}!  Any shared variables referenced by a task will be exposed by command-line when\ninvoking that task. Shared variables referenced by a sub-task will be evaluated\nas needed, but not exposed by command-line.  Tasks that define an argument or option with the same name as a shared task will\noverwrite the value of the shared option for the length of that task, not\nincluding sub-tasks.", 
            "title": "Shared Options"
        }, 
        {
            "location": "/spec/#cli-metadata", 
            "text": "It is also possible to create a custom CLI tool for use outside of a project's\ndirectory by using shell aliases:  alias mycli= tusk -f /path/to/tusk.yml  In that case, it may be useful to override the tool name and usage text that\nare provided as part of the help documentation:  name: mycli\nusage: A custom aliased command-line application\n\ntasks:\n  ...  The example above will produce the following help documentation:  mycli - A custom aliased command-line application\n\nUsage:\n  mycli [global options]  task  [task options]\n\nTasks:\n  ...", 
            "title": "CLI Metadata"
        }, 
        {
            "location": "/spec/#interpolation", 
            "text": "The interpolation syntax for a variable  foo  is  ${foo} , meaning any instances\nof  ${foo}  in the configuration file will be replaced with the value of  foo \nduring execution.  Interpolation is done on a task-by-task basis, meaning args and options defined\nin one task will not interpolate to any other tasks. Shared options, on the\nother hand, will only be evaluated once per execution.  The execution order is as followed:   Shared options are interpolated first, in the order defined by the config\n   file. The results of global interpolation are cached and not re-run.  The args for the current task being run are interpolated, in order.  The options for the current task being run are interpolated, in order.  For each call to a sub-task, the process is repeated, ignoring the task-\n   specific interpolations for parent tasks, using the cached shared options.   This means that options can reference other options or args:  options:\n  name:\n    default: World\n  greeting:\n    default: Hello, ${name}\n\ntasks:\n  greet:\n    run: echo  ${greeting}  Because interpolation is not always desirable, as in the case of environment\nvariables,  $$  will escape to  $  and ignore interpolation. It is also\npossible to use alternative syntax such as  $foo  to avoid interpolation as\nwell. The following two tasks will both use environment variables and not\nattempt interpolation:  tasks:\n  one:\n    run: Hello, $${USER}\n  two:\n    run: Hello, $USER  Interpolation works by substituting the value in the  yaml  config file, then\nparsing the file after interpolation. This means that variable values with\nnewlines or other characters that are relevant to the  yaml  spec or the  sh \ninterpreter will need to be considered by the user. This can be as simple as\nusing quotes when appropriate.", 
            "title": "Interpolation"
        }
    ]
}