<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>The Spec - tusk</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "The Spec";
        var mkdocs_page_input_path = "spec.md";
        var mkdocs_page_url = null;
      </script>
    
    <script src="../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/languages/yaml.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> tusk
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Tusk</a>
                </li>
              </ul>
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="./">The Spec</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#tasks">Tasks</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#run">Run</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#command">Command</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#set-environment">Set Environment</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#sub-tasks">Sub-Tasks</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#when">When</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#args">Args</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#arg-types">Arg Types</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#arg-values">Arg Values</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#options">Options</a>
        <ul>
    <li class="toctree-l4"><a class="reference internal" href="#option-types">Option Types</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#option-defaults">Option Defaults</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#option-values">Option Values</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#required-options">Required Options</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#private-options">Private Options</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#option-rewrite">Option Rewrite</a>
    </li>
    <li class="toctree-l4"><a class="reference internal" href="#shared-options">Shared Options</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#finally">Finally</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#source-target">Source / Target</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#include">Include</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#environment-files">Environment Files</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#interpreter">Interpreter</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#cli-metadata">CLI Metadata</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#interpolation">Interpolation</a>
    </li>
    </ul>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../CONTRIBUTING/">Contributing</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">tusk</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" alt="Docs"></a> &raquo;</li>
      <li>The Spec</li>
    <li class="wy-breadcrumbs-aside">
        <a href="https://github.com/rliebz/tusk/edit/master/docs/spec.md"
          class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="the-spec">The Spec</h1>
<h2 id="tasks">Tasks</h2>
<p>The core of every <code>tusk.yml</code> file is a list of tasks. Tasks are declared at the
top level of the <code>tusk.yml</code> file and include a list of tasks.</p>
<p>For the following tasks:</p>
<pre><code class="language-yaml">tasks:
  hello:
    run: echo &quot;Hello, world!&quot;
  goodbye:
    run: echo &quot;Goodbye, world!&quot;
</code></pre>
<p>The commands can be run with no additional configuration:</p>
<pre><code class="language-console">$ tusk hello
Running: echo &quot;Hello, world!&quot;
Hello, world!
</code></pre>
<p>Tasks can be documented with a one-line <code>usage</code> string and a slightly longer
<code>description</code>. This information will be displayed in help messages:</p>
<pre><code class="language-yaml">tasks:
  hello:
    usage: Say hello to the world
    description: |
      This command will echo &quot;Hello, world!&quot; to the user. There's no
      surprises here.
    run: echo &quot;Hello, world!&quot;
  goodbye:
    run: echo &quot;Goodbye, world!&quot;
</code></pre>
<h3 id="run">Run</h3>
<p>The behavior of a task is defined in its <code>run</code> clause. A <code>run</code> clause can be
used for commands, sub-tasks, or setting environment variables. Although each
<code>run</code> item can only perform one of these actions, they can be run in succession
to handle complex scenarios.</p>
<p>In its simplest form, <code>run</code> can be given a string or list of strings to be
executed serially as shell commands:</p>
<pre><code class="language-yaml">tasks:
  hello:
    run: echo &quot;Hello!&quot;
</code></pre>
<p>This is a shorthand syntax for the following:</p>
<pre><code class="language-yaml">tasks:
  hello:
    run:
      - command:
          exec: echo &quot;Hello!&quot;
</code></pre>
<p>The <code>run</code> clause tasks a list of <code>run</code> items, which allow executing shell
commands with <code>command</code>, setting or unsetting environment variables with
<code>set-environment</code>, running other tasks with <code>task</code>, and controlling conditional
execution with <code>when</code>.</p>
<h4 id="command">Command</h4>
<p>The <code>command</code> clause is the most common thing to do during a <code>run</code>, so for
convenience, passing a string or single item will be correctly interpreted.
Here are several examples of equivalent <code>run</code> clauses:</p>
<pre><code class="language-yaml">run: echo &quot;Hello!&quot;

run:
  - echo &quot;Hello!&quot;

run:
  command: echo &quot;Hello!&quot;

run:
  - command: echo &quot;Hello!&quot;

run:
  - command:
      exec: echo &quot;Hello!&quot;
</code></pre>
<p>While the interpreter cannot be set for an individual command, it is possible
to set them globally using <a href="#interpreter">the interpreter clause</a>.</p>
<h5 id="exec">Exec</h5>
<p>The <code>exec</code> clause contains the actual shell command to be performed.</p>
<p>If any of the run commands execute with a non-zero exit code, Tusk will
immediately exit with the same exit code without executing any other commands.</p>
<p>Each command in a <code>run</code> clause gets its own sub-shell, so things like declaring
functions and environment variables will not be available across separate run
commmands, although it is possible to run the <code>set-environment</code> clause or use a
multi-line shell command.</p>
<p>When using POSIX interpreters with multi-line scripts, it is recommend to run
<code>set -e</code> at the top of the script, to preserve the exit-on-error behavior.</p>
<pre><code class="language-yaml">tasks:
  hello:
    run: |
      set -e
      errcho() {
        &gt;&amp;2 echo &quot;$@&quot;
      }
      errcho &quot;Hello, world!&quot;
      errcho &quot;Goodbye, world!&quot;
</code></pre>
<h5 id="print">Print</h5>
<p>Sometimes it may not be desirable to print the exact command run, for example,
if it's overly verbose or contains secrets. In that case, the <code>command</code> clause
can be passed a <code>print</code> string to use as an alternative:</p>
<pre><code class="language-yaml">tasks:
  hello:
    run:
      command:
        exec: echo &quot;SECRET_VALUE&quot;
        print: echo &quot;*****&quot;
</code></pre>
<h5 id="quiet">Quiet</h5>
<p>Sometimes you may not want to print the command-to-be-run at all. In that case,
the <code>quiet</code> clause can be used. This is comparable to the global <code>-q</code>/<code>--quiet</code>
command-line flag in that it silence's Tusk's logging without silencing the
command output:</p>
<pre><code class="language-yaml">tasks:
  hello:
    run:
      command:
        exec: curl http://example.com
        quiet: true
</code></pre>
<p>This property can also be set for an entire task and is inherited by any
sub-task. In both of these cases the executed commands are not printed:</p>
<pre><code class="language-yaml">tasks:
  quiet-parent:
    quiet: true
    run:
      task: normal-child
  normal-child:
    run: curl http://example.com

  normal-parent:
    run:
      task: quiet-child
  quiet-child:
    quiet: true
    run: curl http://example.com
</code></pre>
<h5 id="dir">Dir</h5>
<p>The <code>dir</code> clause sets the working directory for a specific command:</p>
<pre><code class="language-yaml">tasks:
  hello:
    run:
      command:
        exec: echo &quot;Hello from $PWD!&quot;
        dir: ./subdir
</code></pre>
<h4 id="set-environment">Set Environment</h4>
<p>To set or unset environment variables, simply define a map of environment
variable names to their desired values:</p>
<pre><code class="language-yaml">tasks:
  hello:
    options:
      proxy-url:
        default: http://proxy.example.com
    run:
      - set-environment:
          http_proxy: ${proxy-url}
          https_proxy: ${proxy-url}
          no_proxy: ~
      - command: curl http://example.com
</code></pre>
<p>Passing <code>~</code> or <code>null</code> to an environment variable will explicitly unset it,
while passing an empty string will set it to an empty string.</p>
<p>Environment variables once modified will persist until Tusk exits.</p>
<h4 id="sub-tasks">Sub-Tasks</h4>
<p>Run can also execute previously-defined tasks:</p>
<pre><code class="language-yaml">tasks:
  one:
    run: echo &quot;Inside one&quot;
  two:
    run:
      - task: one
      - command: echo &quot;Inside two&quot;
</code></pre>
<p>For any arg or option that a sub-task defines, the parent task can pass a
value, which is treated the same way as passing by command-line would be. Args
are passed in as a list, while options are a map from flag name to value.</p>
<p>To pass values, use the long definition of a sub-task:</p>
<pre><code class="language-yaml">tasks:
  greet:
    args:
      name:
        usage: The person to greet
    options:
      greeting:
        default: Hello
    run: echo &quot;${greeting}, ${person}!&quot;
  greet-myself:
    run:
      task:
        name: greet
        args:
          - me
        options:
          greeting: Howdy
</code></pre>
<p>In cases where a sub-task may not be useful on its own, define it as private to
prevent it from being invoked directly from the command-line. For example:</p>
<pre><code class="language-yaml">tasks:
  configure-environment:
    private: true
    run:
      set-environment: { APP_ENV: dev }
  serve:
    run:
      - task: configure-environment
      - command: python main.py
</code></pre>
<h4 id="when">When</h4>
<p>For conditional execution, <code>when</code> clauses are available.</p>
<pre><code class="language-yaml">run:
  when:
    os: linux
  command: echo &quot;This is a linux machine&quot;
</code></pre>
<p>In a <code>run</code> clause, any item with a true <code>when</code> clause will execute. There are
five different checks supported:</p>
<ul>
<li><code>command</code> (list): Execute if any command runs with an exit code of <code>0</code>.
  Commands will execute in the order defined and stop execution at the first
  successful command.</li>
<li><code>exists</code> (list): Execute if any of the listed files exists.</li>
<li><code>not-exists</code> (list): Execute if any of the listed files doesn't exist.</li>
<li><code>os</code> (list): Execute if the operating system matches any one from the list.</li>
<li><code>environment</code> (map[string -&gt; list]): Execute if the environment variable
  matches any of the values it maps to. To check if a variable is not set, the
  value should be <code>~</code> or <code>null</code>.</li>
<li><code>equal</code> (map[string -&gt; list]): Execute if the given option equals any of the
  values it maps to.</li>
<li><code>not-equal</code> (map[string -&gt; list]): Execute if the given option is not equal to
  any one of the values it maps to.</li>
</ul>
<p>The <code>when</code> clause supports any number of different checks as a list, where each
check must pass individually for the clause to evaluate to true. Here is a more
complicated example of how <code>when</code> can be used:</p>
<pre><code class="language-yaml">tasks:
  echo:
    options:
      cat:
        usage: Cat a file
    run:
      - when:
          os:
            - linux
            - darwin
        command: echo &quot;This is a unix machine&quot;
      - when:
          - exists: my_file.txt
          - equal: { cat: true }
          - command: command -v cat
        command: cat my_file.txt
</code></pre>
<h5 id="short-form">Short Form</h5>
<p>Because it's common to check if a boolean flag is set to true, <code>when</code> clauses
also accept strings as shorthand. Consider the following example, which checks
to see if some option <code>foo</code> has been set to <code>true</code>:</p>
<pre><code class="language-yaml">when:
  equal: { foo: true }
</code></pre>
<p>This can be expressed more succinctly as the following:</p>
<pre><code class="language-yaml">when: foo
</code></pre>
<h5 id="when-anyall-logic">When Any/All Logic</h5>
<p>A <code>when</code> clause takes a list of items, where each item can have multiple checks.
Each <code>when</code> item will pass if <em>any</em> of the checks pass, while the whole clause
will only pass if <em>all</em> of the items pass. For example:</p>
<pre><code class="language-yaml">tasks:
  exists:
    run:
      - when:
          # There is a single `when` item with two checks
          exists:
            - file_one.txt
            - file_two.txt
        command: echo &quot;At least one file exists&quot;
      - when:
          # There are two separate `when` items with one check each
          - exists: file_one.txt
          - exists: file_two.txt
        command: echo &quot;Both files exist&quot;
</code></pre>
<p>These properties can be combined for more complicated logic:</p>
<pre><code class="language-yaml">tasks:
  echo:
    options:
      verbose:
        type: bool
      ignore-os:
        type: bool
    run:
      - when:
          # (OS is linux OR darwin OR ignore OS is true) AND (verbose is true)
          - os:
              - linux
              - darwin
            equal: { ignore-os: true }
          - equal: { verbose: true }
        command: echo &quot;This is a unix machine&quot;
</code></pre>
<h3 id="args">Args</h3>
<p>Tasks may have args that are passed directly as inputs. Any arg that is defined
is required for the task to execute.</p>
<pre><code class="language-yaml">tasks:
  greet:
    args:
      name:
        usage: The person to greet
    run: echo &quot;Hello, ${name}!&quot;
</code></pre>
<p>The task can be invoked as such:</p>
<pre><code class="language-console">$ tusk greet friend
Hello, friend!
</code></pre>
<h4 id="arg-types">Arg Types</h4>
<p>Args can be of the types <code>string</code>, <code>integer</code>, <code>float</code>, or <code>boolean</code>. Args
without types specified are considered strings.</p>
<pre><code class="language-yaml">tasks:
  add:
    args:
      a:
        type: int
      b:
        type: int
    run: echo $((${a} + ${b}))
</code></pre>
<h4 id="arg-values">Arg Values</h4>
<p>Args can specify which values are considered valid:</p>
<pre><code class="language-yaml">tasks:
  greet:
    args:
      name:
        values:
          - Abby
          - Bobby
          - Carl
</code></pre>
<p>Any value passed by command-line must be one of the listed values, or the
command will fail to execute.</p>
<h3 id="options">Options</h3>
<p>Tasks may have options that are passed as GNU-style flags. The following
configuration will provide <code>-n, --name</code> flags to the CLI and help documentation,
which will then be interpolated:</p>
<pre><code class="language-yaml">tasks:
  greet:
    options:
      name:
        usage: The person to greet
        short: n
        environment: GREET_NAME
        default: World
    run: echo &quot;Hello, ${name}!&quot;
</code></pre>
<p>The above configuration will evaluate the value of <code>name</code> in order of highest
priority:</p>
<ol>
<li>The value passed by command line flags (<code>-n</code> or <code>--name</code>)</li>
<li>The value of the environment variable (<code>GREET_NAME</code>), if set</li>
<li>The value set in default</li>
</ol>
<p>For short flag names, values can be combined such that <code>tusk foo -ab</code> is exactly
equivalent to <code>tusk foo -a -b</code>.</p>
<h4 id="option-types">Option Types</h4>
<p>Options can be of the types <code>string</code>, <code>integer</code>, <code>float</code>, or <code>boolean</code>, using
the zero-value of that type as the default if not set. Options without types
specified are considered strings.</p>
<p>For boolean values, the flag should be passed by command line without any
arugments. In the following example:</p>
<pre><code class="language-yaml">tasks:
  greet:
    options:
      loud:
        type: bool
    run:
      - when:
          equal: { loud: true }
        command: echo &quot;HELLO!&quot;
      - when:
          equal: { loud: false }
        command: echo &quot;Hello.&quot;
</code></pre>
<p>The flag should be passed as such:</p>
<pre><code class="language-bash">tusk greet --loud
</code></pre>
<p>This means that for an option that is true by default, the only way to disable
it is with the following syntax:</p>
<pre><code class="language-bash">tusk greet --loud=false
</code></pre>
<p>Of course, options can always be defined in the reverse manner to avoid this
issue:</p>
<pre><code class="language-yaml">options:
  no-loud:
    type: bool
</code></pre>
<h4 id="option-defaults">Option Defaults</h4>
<p>Much like <code>run</code> clauses accept a shorthand form, passing a string to <code>default</code>
is shorthand. The following options are exactly equivalent:</p>
<pre><code class="language-yaml">options:
  short:
    default: foo
  long:
    default:
      - value: foo
</code></pre>
<p>A <code>default</code> clause can also register the <code>stdout</code> of a command as its value:</p>
<pre><code class="language-yaml">options:
  os:
    default:
      command: uname -s
</code></pre>
<p>A <code>default</code> clause also accepts a list of possible values with a corresponding
<code>when</code> clause. The first <code>when</code> that evaluates to true will be used as the
default value, with an omitted <code>when</code> always considered true.</p>
<p>In this example, linux users will have the name <code>Linux User</code>, while the default
for all other OSes is <code>User</code>:</p>
<pre><code class="language-yaml">options:
  name:
    default:
      - when:
          os: linux
        value: Linux User
      - value: User
</code></pre>
<h4 id="option-values">Option Values</h4>
<p>Like args, an option can specify which values are considered valid:</p>
<pre><code class="language-yaml">options:
  number:
    default: zero
    values:
      - one
      - two
      - three
</code></pre>
<p>Any value passed by command-line flags or environment variables must be one of
the listed values. Default values, including commands, are excluded from this
requirement.</p>
<h4 id="required-options">Required Options</h4>
<p>Options may be required if there is no sane default value. For a required flag,
the task will not execute unless the flag is passed:</p>
<pre><code class="language-yaml">options:
  file:
    required: true
</code></pre>
<p>A required option cannot be private or have any default values.</p>
<h4 id="private-options">Private Options</h4>
<p>Sometimes it may be desirable to have a variable that cannot be directly
modified through command-line flags. In this case, use the <code>private</code> option:</p>
<pre><code class="language-yaml">options:
  user:
    private: true
    default:
      command: whoami
</code></pre>
<p>A private option will not accept environment variables or command line flags,
and it will not appear in the help documentation.</p>
<h4 id="option-rewrite">Option Rewrite</h4>
<p>Boolean values are convenient as CLI inputs, but the interpolated output of
<code>true</code> or <code>false</code> is often not. Use the <code>rewrite</code> clause to change the
interpolation behavior from <code>true</code>/<code>false</code> to a conditional specified string:</p>
<pre><code class="language-yaml">tasks:
  greet:
    options:
      verbose:
        type: boolean
        rewrite: --level=verbose
    run: mycli greet ${verbose}
</code></pre>
<p>The above will interpolate to eitehr <code>mycli greet</code> or <code>mycli greet --level=verbose</code>
depending on whether the <code>--verbose</code> flag is passed.</p>
<p>Note that once a boolean option has been rewritten, the output is no longer
<code>true</code>/<code>false</code>, which means <code>when: verbose</code> in the above example would never
evaluate to true.</p>
<h4 id="shared-options">Shared Options</h4>
<p>Options may also be defined at the root of the config file to be shared between
tasks:</p>
<pre><code class="language-yaml">options:
  name:
    usage: The person to greet
    default: World

tasks:
  hello:
    run: echo &quot;Hello, ${name}!&quot;
  goodbye:
    run: echo &quot;Goodbye, ${name}!&quot;
</code></pre>
<p>Any shared variables referenced by a task will be exposed by command-line when
invoking that task. Shared variables referenced by a sub-task will be evaluated
as needed, but not exposed by command-line.</p>
<p>Tasks that define an argument or option with the same name as a shared task will
overwrite the value of the shared option for the length of that task, not
including sub-tasks.</p>
<h3 id="finally">Finally</h3>
<p>The <code>finally</code> clause is run after a task's <code>run</code> logic has completed, whether or
not that task was successful. This can be useful for clean-up logic. A <code>finally</code>
clause has the same format as a <code>run</code> clause:</p>
<!-- prettier-ignore-start -->

<pre><code class="language-yaml">tasks:
  hello:
    run:
      - echo &quot;Hello&quot;
      - exit 1          # `run` clause stops here
      - echo &quot;Oops!&quot;    # Never prints
    finally:
      - echo &quot;Goodbye&quot;  # Always prints
      - task: cleanup
  # ...
</code></pre>
<!-- prettier-ignore-end -->

<p>If the <code>finally</code> clause runs an unsuccessful command, it will terminate early
the same way that a <code>run</code> clause would. The exit code is still passed back to
the command line. However, if both the <code>run</code> clause and <code>finally</code> clause fail,
the exit code from the <code>run</code> clause takes precedence.</p>
<h3 id="source-target">Source / Target</h3>
<p>For tasks that generate files from other files, it often makes sense to skip
work when those generated files are already up-to-date. For this, tasks can
specify a <code>source</code> and <code>target</code>:</p>
<pre><code class="language-yaml">tasks:
  generate:
    source:
      - generate.sh
      - data/**
    target: output.txt
    run: ./generate.sh
</code></pre>
<p>The <code>source</code> and <code>target</code> clauses are each specified as one or more filepath
patterns relative to the config file using <a href="https://github.com/bmatcuk/doublestar?tab=readme-ov-file#patterns">glob pattern syntax</a>.
Both <code>source</code> and <code>target</code> must be specified together.</p>
<p>All specified sources must exist. For each individual glob entry, at least one
file must match the pattern.</p>
<p>If all target patterns exist and have newer timestamps than the newest source
pattern, the task will be skipped. Otherwise, the task will execute as normal.</p>
<p>With directories, in most cases you'll want to use a pattern to specify the
files in the directory for tracking changes rather than the directory itself.</p>
<p>The task run history can be managed with the <code>--clean-cache</code>,
<code>--clean-project-cache</code>, and <code>--clean-task-cache</code> flags.</p>
<h3 id="include">Include</h3>
<p>In some cases it may be desirable to split the task definition into a separate
file. The <code>include</code> clause serves this purpose. At the top-level of a task, a
task may optionally be specified using just the <code>include</code> key, which maps to a
separate file where there task definition is stored.</p>
<p>For example, <code>tusk.yml</code> could be written like this:</p>
<pre><code class="language-yaml">tasks:
  hello:
    include: .tusk/hello.yml
</code></pre>
<p>With a <code>.tusk/hello.yml</code> that looks like this:</p>
<pre><code class="language-yaml">options:
  name:
    usage: The person to greet
    default: World
run: echo &quot;Hello, ${name}!&quot;
</code></pre>
<p>It is invalid to split the configuration; if the <code>include</code> clause is used, no
other keys can be specified in the <code>tusk.yml</code>, and the full task must be
defined in the included file.</p>
<h2 id="environment-files">Environment Files</h2>
<p>Environment variables are also automatically read from a <code>.env</code> file in the
same directory as <code>tusk.yml</code> before task execution. This file is optional by
default, and supports typical "dotenv" extended syntax such as quotation marks,
comments, variable substitution, and the <code>export</code> keyword.</p>
<p>A typical file might look like this:</p>
<pre><code class="language-sh">FOO=foovalue
BAR=barvalue
</code></pre>
<p>Environment files can be explicitly specified as configuration at the
top-level:</p>
<pre><code class="language-yaml">env-file: .local.env
</code></pre>
<p>This is shorthand syntax for the following:</p>
<pre><code class="language-yaml">env-file:
  - path: .local.env
    required: true
</code></pre>
<p>Multiple environment files can be specified. Entries are evaluted in order, so
environment variables from later files override values specified in previous
entries.</p>
<p>Specifying any value for <code>env-file</code> will disable the default behavior of
auto-loading an optional <code>.env</code>. To re-enable it, specify it explicitly:</p>
<pre><code class="language-yaml">env-file:
  - path: .env
    required: false
  - .local.env
</code></pre>
<p>To disable loading environment files completely, pass <code>[]</code> or <code>/dev/null</code>:</p>
<pre><code class="language-yaml">env-file: []
</code></pre>
<h2 id="interpreter">Interpreter</h2>
<p>By default, any command run will default to using <code>sh -c</code> as its interpreter.
This can optionally be configured using the <code>interpreter</code> clause.</p>
<p>The interpreter is specified as an executable, which can either be an absolute
path or available on the user's PATH, followed by a series of optional
arguments:</p>
<pre><code class="language-yaml">interpreter: node -e

tasks:
  hello:
    run: console.log(&quot;Hello!&quot;)
</code></pre>
<p>The commands specified in individual tasks will be passed as the final
argument. The above example is effectively equivalent to the following:</p>
<pre><code class="language-sh">node -e 'console.log(&quot;Hello!&quot;)'
</code></pre>
<h2 id="cli-metadata">CLI Metadata</h2>
<p>It is also possible to create a custom CLI tool for use outside of a project's
directory by using shell aliases:</p>
<pre><code class="language-bash">alias mycli=&quot;tusk -f /path/to/tusk.yml&quot;
</code></pre>
<p>In that case, it may be useful to override the tool name and usage text that
are provided as part of the help documentation:</p>
<pre><code class="language-yaml">name: mycli
usage: A custom aliased command-line application

tasks:
  # ...
</code></pre>
<p>The example above will produce the following help documentation:</p>
<pre><code class="language-console">$ tusk --help
mycli - A custom aliased command-line application

Usage:
  mycli [global options] &lt;task&gt; [task options]

Tasks:
  ...
</code></pre>
<h2 id="interpolation">Interpolation</h2>
<p>The interpolation syntax for a variable <code>foo</code> is <code>${foo}</code>, meaning any instances
of <code>${foo}</code> in the configuration file will be replaced with the value of <code>foo</code>
during execution.</p>
<p>Interpolation is done on a task-by-task basis, meaning args and options defined
in one task will not interpolate to any other tasks. Shared options, on the
other hand, will only be evaluated once per execution.</p>
<p>The execution order is as followed:</p>
<ol>
<li>Shared options are interpolated first, in the order defined by the config
   file. The results of global interpolation are cached and not re-run.</li>
<li>The args for the current task being run are interpolated, in order.</li>
<li>The options for the current task being run are interpolated, in order.</li>
<li>For each call to a sub-task, the process is repeated, ignoring the task-
   specific interpolations for parent tasks, using the cached shared options.</li>
</ol>
<p>This means that options can reference other options or args:</p>
<pre><code class="language-yaml">options:
  name:
    default: World
  greeting:
    default: Hello, ${name}

tasks:
  greet:
    run: echo &quot;${greeting}&quot;
</code></pre>
<p>Because interpolation is not always desirable, as in the case of environment
variables, <code>$$</code> will escape to <code>$</code> and ignore interpolation. It is also
possible to use alternative syntax such as <code>$foo</code> to avoid interpolation as
well. The following two tasks will both use environment variables and not
attempt interpolation:</p>
<pre><code class="language-yaml">tasks:
  one:
    run: Hello, $${USER}
  two:
    run: Hello, $USER
</code></pre>
<p>Interpolation works by substituting the value in the <code>yaml</code> config file, then
parsing the file after interpolation. This means that variable values with
newlines or other characters that are relevant to the <code>yaml</code> spec or the <code>sh</code>
interpreter will need to be considered by the user. This can be as simple as
using quotes when appropriate.</p>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href=".." class="btn btn-neutral float-left" title="Tusk"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../CONTRIBUTING/" class="btn btn-neutral float-right" title="Contributing">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/rliebz/tusk" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href=".." style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../CONTRIBUTING/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme_extra.js" defer></script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
